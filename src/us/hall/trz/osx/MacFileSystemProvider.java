package us.hall.trz.osx;import java.io.IOException;import java.net.URI;import java.nio.channels.SeekableByteChannel;import java.nio.file.AccessMode;import java.nio.file.CopyOption;import java.nio.file.DirectoryStream;import java.nio.file.DirectoryStream.Filter;import java.nio.file.FileStore;import java.nio.file.FileSystem;import java.nio.file.OpenOption;import java.nio.file.Path;import java.nio.file.LinkOption;import java.nio.file.attribute.BasicFileAttributes;import java.nio.file.attribute.FileAttribute;import java.nio.file.attribute.FileAttributeView;import java.nio.file.spi.FileSystemProvider;import java.util.List;import java.util.Map;import java.util.Set;/** * Mac platform specific attributes provider *  * @author mjh * */public class MacFileSystemProvider extends FileSystemProvider {    private final FileSystemProvider priorProvider;    private static final String scheme = "file";        /**     * This may be used as a 'helper' provider for attributes or whatever     * so the no arg constructor may be used and simply sets priorProvider to the      * first found 'file' scheme provider - which should be the 'default' platform     * provider.     */    public MacFileSystemProvider() {    	List<FileSystemProvider> providers = FileSystemProvider.installedProviders();    	for (FileSystemProvider provider : providers) {    		if (provider.getScheme().equals(scheme)) {    			priorProvider = provider;    			return;    		}    	}    	// Hopefully, shouldn't happen    	priorProvider = null;     }	    public MacFileSystemProvider(FileSystemProvider fsp) {     	priorProvider = fsp;     }	    /**     * Splits the given attribute name into the name of an attribute view and     * the attribute. If the attribute view is not identified then it assumed     * to be "basic".     */    private static String[] split(String attribute) {        String[] s = new String[2];        int pos = attribute.indexOf(':');        if (pos == -1) {            s[0] = "basic";            s[1] = attribute;        } else {            s[0] = attribute.substring(0, pos++);            s[1] = (pos == attribute.length()) ? "" : attribute.substring(pos);        }        return s;    }        @Override    public void setAttribute(Path path, String attribute,                             Object value, LinkOption... options)        throws IOException    {        String[] s = split(attribute);        if (s[0].length() == 0)            throw new IllegalArgumentException(attribute);        MacFileAttributeView macview = getFileAttributeView(path, s[0], options);        if (macview == null)         	priorProvider.setAttribute(path,attribute,options);        macview.setAttribute(s[1],value);    }        @Override    public <A extends BasicFileAttributes> A        readAttributes(Path path, Class<A> type, LinkOption... options)        throws IOException    {        return priorProvider.readAttributes(((MacPath)path).getProxy(),type,options);    }     @Override    public Map<String, Object>        readAttributes(Path path, String attributes, LinkOption... options)        throws IOException    {        String[] s = split(attributes);        if (s[0].length() == 0)            throw new IllegalArgumentException(attributes);        MacFileAttributeView macview = getFileAttributeView(path, s[0], options);        if (macview == null)         	return priorProvider.readAttributes(path,attributes,options);        return macview.readAttributes(s[1].split(","));    }        @Override    @SuppressWarnings("unchecked")    public <V extends FileAttributeView> V        getFileAttributeView(Path path, Class<V> type, LinkOption... options)    {        boolean followLinks =  followLinks(options);    	if (type == MacLSFileAttributeView.class)    		return (V) new LS(path,followLinks);    	if (type == MacFinderFileAttributeView.class)    		return (V) new Finder(path,followLinks);    		        return priorProvider.getFileAttributeView(path,type,options);    }        protected MacFileAttributeView getFileAttributeView(Path obj,                                                            String name,                                                            LinkOption... options)    {    	boolean followLinks = followLinks(options);        if (name.equals("mac_finder"))            return new Finder(obj, followLinks);        if (name.equals("mac_ls"))            return new LS(obj, followLinks);        if (name.equals("mac_cocoa"))        	return new Cocoa(obj, followLinks);        if (name.equals("mac_xattr"))        	return new XAttr(obj, followLinks);        return null;    }        boolean followLinks(LinkOption... options) {        boolean followLinks = true;        for (LinkOption option: options) {            if (option == LinkOption.NOFOLLOW_LINKS) {                followLinks = false;                continue;            }            if (option == null)                throw new NullPointerException();            throw new AssertionError("Should not get here");        }        return followLinks;    }        @Override    public void checkAccess(Path path, AccessMode... modes) throws IOException {    	if (path instanceof MacPath)     		priorProvider.checkAccess(((MacPath)path).getProxy());    	else    		priorProvider.checkAccess(path,modes);    }        @Override    public FileStore getFileStore(Path path) throws IOException {    	if (path instanceof MacPath)      		return priorProvider.getFileStore(((MacPath)path).getProxy());    	return priorProvider.getFileStore(path);    }        @Override    public boolean isHidden(Path path) throws IOException {    	if (path instanceof MacPath) return isHidden(((MacPath)path).getProxy());        return priorProvider.isHidden(path);    }        @Override    public boolean isSameFile(Path path, Path other) throws IOException {    	if ((path instanceof MacPath) && (other instanceof MacPath))    		return priorProvider.isSameFile(((MacPath)path).getProxy(), ((MacPath)other).getProxy());        return priorProvider.isSameFile(path,other);    }        @Override    public void move(Path src, Path target, CopyOption... options)        throws IOException    {    	if ((src instanceof MacPath) && (target instanceof MacPath))    		priorProvider.move(((MacPath)src).getProxy(),((MacPath)target).getProxy(),options);    	else priorProvider.move(src,target,options);    }        @Override    public void copy(Path src, Path target, CopyOption... options)        throws IOException    {    	if ((src instanceof MacPath) && (target instanceof MacPath))     		priorProvider.copy(((MacPath)src).getProxy(),((MacPath)target).getProxy(),options);    	else priorProvider.copy(src,target,options);    }        @Override    public final void delete(Path path) throws IOException {    	if (path instanceof MacPath)     		priorProvider.delete(((MacPath)path).getProxy());    	else priorProvider.delete(path);    }        @Override    public void createDirectory(Path path, FileAttribute<?>... attrs)        throws IOException    {    	// TODO need to see if mac_ attributes and handle appropriately    	if (path instanceof MacPath)    		priorProvider.createDirectory(((MacPath)path).getProxy(),attrs);    	else priorProvider.createDirectory(path,attrs);    }        @Override    public DirectoryStream<Path> newDirectoryStream(        Path path, Filter<? super Path> filter) throws IOException    {    	if (path instanceof MacPath)     		return priorProvider.newDirectoryStream(((MacPath)path).getProxy(),filter);        return priorProvider.newDirectoryStream(path,filter);    }         @Override    public SeekableByteChannel newByteChannel(Path path,                                              Set<? extends OpenOption> options,                                              FileAttribute<?>... attrs)        throws IOException    {    	if (path instanceof MacPath)     		return priorProvider.newByteChannel(((MacPath)path).getProxy(),options,attrs);        return priorProvider.newByteChannel(path,options,attrs);    }        @Override    public Path getPath(URI uri) {		return priorProvider.getPath(uri);    }    @Override    public FileSystem getFileSystem(URI uri) {       if (uri.getScheme().equals(scheme))    		return new MacFileSystem(this,priorProvider);       else return priorProvider.getFileSystem(uri);    }        @Override    public FileSystem newFileSystem(URI uri, Map<String, ?> env)        throws IOException    {       return priorProvider.newFileSystem(uri,env);    }        @Override    public String getScheme() {       return "file";    }}